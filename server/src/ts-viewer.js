"use strict";
const TeamspeakQuery = require("teamspeak-query");
const EventEmitter = require("eventemitter2");

const TsClient = require("./ts-client");
const TsChannel = require("./ts-channel");
const TsServer = require("./ts-server");

class TsViewer extends EventEmitter {
  constructor(config) {
    super();

    this._config = config;
    this._query = new TeamspeakQuery.Raw({
      host: this._config.queryAddress,
      port: this._config.queryPort
    });
    this._query.keepalive.enable();
    this._query.keepalive.setDuration(240);

    this._currentServer = new TsServer(config);
  }

  get currentServer() {
    return this._currentServer;
  }

  async start() {
    await this._setup();
    await this._update();

    this._query.on("cliententerview", clientinfo => {
      if (this._config.enableClientConnectionHistory) {
        const clientConnectionInfo = {
          clid: clientinfo.clid,
          client_nickname: clientinfo.client_nickname,
          time_connected: new Date()
        };

        this._currentServer.logConnection(
          clientConnectionInfo,
          this._config.maxClientConnectionHistory
        );

        this.emit(
          "cliententerview",
          this._currentServer.getConnectionHistory()
        );
      }

      this._update();
    });

    this._query.on("clientleftview", clientinfo => {
      if (this._config.enableClientConnectionHistory) {
        /*
          We need to get the client manually because the response (clientinfo)
          does not include the client's nickname.
  
          This must be done before updating is called.
        */
        let client = this._currentServer.getClient(clientinfo.clid);

        /*
          In the rare case that a user connects and immediately disconnects,
          before the ts-viewer has had a chance to update properly, the user
          basically cannot be identified. This is an unfortunate consequence
          of the response generated by clientleftview (i.e. no client_nickname 
          is provided and there is no possible way to query for it at this point).
          
          It seems there is no proper solution. Therefore, we set the client's
          nickname to some 'unidentified' value.
        */
        const clientDisconnectionInfo = {
          clid: clientinfo.clid,
          client_nickname: client !== null ? client.client_nickname : "?",
          time_disconnected: new Date()
        };

        this._currentServer.logConnection(
          clientDisconnectionInfo,
          this._config.maxClientConnectionHistory
        );

        this.emit("clientleftview", this._currentServer.getConnectionHistory());
      }

      this._update();
    });
    
    this._query.on("clientmoved", _ => this._update());
    this._query.on("channelcreated", _ => this._update());
    this._query.on("channeledited", _ => this._update());
    this._query.on("channelmoved", _ => this._update());
  }

  async stop() {
    await this._query.disconnect();
  }

  async _setup() {
    try {
      await this._query.send(
        "login",
        this._config.queryUser,
        this._config.queryPass
      );

      await this._query.send("use", {
        sid: this._config.querySID,
        port: this._config.queryVirtualServerPort
      });

      // cliententerview, clientleftview, serveredited
      await this._query.send("servernotifyregister", {
        event: "channel",
        id: 0
      });

      console.log(
        `TsViewer setup complete. ` +
          `Now listening for incoming TS connections on ` +
          `port ${this._config.queryVirtualServerPort}...`
      );
    } catch (err) {
      console.error("Could not setup:", err);
    }
  }

  async _update() {
    Promise.all([
      this._query.send("serverlist"),
      this._getCurrentChannels(),
      this._getCurrentOnlineClients()
    ])
      .then(values => {
        this._currentServer.update(
          values[0].virtualserver_name,
          values[1],
          values[2]
        );
        this.emit("update", this._currentServer);
      })
      .catch(err => {
        console.error("Could not update " + err);
      });
  }

  async _getCurrentChannels() {
    const currentChannels = [];

    try {
      const res = await this._query.send("channellist");
      const channelSpacerRegex = new RegExp(".*spacer.*");
      for (let i = 0; i < res.channel_order.length; i++) {
        if (
          !this._config.allowChannelSpacers &&
          channelSpacerRegex.test(res.channel_name[i])
        ) {
          continue;
        }

        currentChannels.push(new TsChannel(res.cid[i], res.channel_name[i]));
      }
    } catch (err) {
      console.error("Could not get channellist:", err);
    }

    return currentChannels;
  }

  async _getCurrentOnlineClients() {
    const onlineClients = [];

    try {
      const res = await this._query.send("clientlist");
      const serverQueryAdminRegex = new RegExp(".*(s|S)erver.*");
      for (let i = 0; i < res.clid.length; i++) {
        if (
          !this._config.displayServerQueryUsers &&
          serverQueryAdminRegex.test(res.client_nickname[i])
        ) {
          continue;
        }
        onlineClients.push(
          new TsClient(res.clid[i], res.client_nickname[i], res.cid[i])
        );
      }
    } catch (err) {
      console.error("Could not get clientlist:", err);
    }

    return onlineClients;
  }
}

module.exports = TsViewer;
