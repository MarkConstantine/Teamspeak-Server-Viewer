"use strict";
const TeamspeakQuery = require("teamspeak-query");
const EventEmitter = require("eventemitter2");

const TsClient = require("./ts-client");
const TsChannel = require("./ts-channel");
const TsServer = require("./ts-server");

class TsViewer extends EventEmitter {
  constructor(config) {
    super();

    this._config = config;
    this._query = new TeamspeakQuery.Raw({
      host: this._config.queryAddress,
      port: this._config.queryPort
    });
    this._query.keepalive.enable();
    this._query.keepalive.setDuration(240);

    this._currentServer = new TsServer(config);
  }

  get currentServer() {
    return this._currentServer;
  }

  async start() {
    await this._setup();
    await this._update();

    this._query.on("cliententerview", clientEnterInfo => {
      if (
        this._config.enableClientConnectionHistory &&
        !this._isIgnoredUser(
          this._config.ignoreUsersRegexList,
          clientEnterInfo.client_nickname
        )
      ) {
        const clientConnectionInfo = {
          clid: clientEnterInfo.clid,
          client_nickname: clientEnterInfo.client_nickname,
          time_connected: new Date()
        };

        this._currentServer.logConnection(
          clientConnectionInfo,
          this._config.maxClientConnectionHistory
        );

        this.emit(
          "cliententerview",
          this._currentServer.getConnectionHistory()
        );
      }

      this._update();
    });

    this._query.on("clientleftview", clientLeavingInfo => {
      if (this._config.enableClientConnectionHistory) {
        /*
          We need to get the client manually because the response (clientLeavingInfo)
          does not include the client's nickname. This must be done before update is called.
        */
        let client = this._currentServer.getClient(clientLeavingInfo.clid);

        /*
          In the rare case that a user connects and immediately disconnects,
          before the ts-viewer has had a chance to update properly, the user
          basically cannot be identified. This is an unfortunate consequence
          of the response generated by clientleftview (i.e. no client_nickname 
          is provided and there is no possible way to query for it at this point).
          
          It seems there is no proper solution. Therefore, we ignore logging users
          who cannot be identified. This means it's possible for a user to have a
          connect message but never a disconnect message.
        */
        if (client === null) return; // Ignoring unidentified user.

        const clientDisconnectionInfo = {
          clid: clientLeavingInfo.clid,
          client_nickname: client.client_nickname,
          time_disconnected: new Date()
        };

        this._currentServer.logConnection(
          clientDisconnectionInfo,
          this._config.maxClientConnectionHistory
        );

        this.emit("clientleftview", this._currentServer.getConnectionHistory());
      }

      this._update();
    });

    this._query.on("clientmoved", _ => this._update());
    this._query.on("channelcreated", _ => this._update());
    this._query.on("channeledited", _ => this._update());
    this._query.on("channelmoved", _ => this._update());
  }

  async stop() {
    await this._query.disconnect();
  }

  _isIgnoredUser(ignoredUserRegexList, clientNickname) {
    for (const regexStr of ignoredUserRegexList) {
      const regex = new RegExp(regexStr);
      if (regex.test(clientNickname)) {
        return true;
      }
    }
    return false;
  }

  async _setup() {
    try {
      await this._query.send(
        "login",
        this._config.queryUser,
        this._config.queryPass
      );

      await this._query.send("use", {
        sid: this._config.querySID,
        port: this._config.queryVirtualServerPort
      });

      // cliententerview, clientleftview, serveredited
      await this._query.send("servernotifyregister", {
        event: "channel",
        id: 0
      });

      console.log(
        `TsViewer setup complete. ` +
          `Now listening for incoming TS connections on ` +
          `port ${this._config.queryVirtualServerPort}...`
      );
    } catch (err) {
      console.error("Could not setup:", err);
    }
  }

  async _update() {
    Promise.all([
      this._query.send("serverlist"),
      this._getCurrentChannels(),
      this._getCurrentOnlineClients()
    ])
      .then(values => {
        this._currentServer.update(
          values[0].virtualserver_name,
          values[1],
          values[2]
        );
        this.emit("update", this._currentServer);
      })
      .catch(err => {
        console.error("Could not update " + err);
      });
  }

  async _getCurrentChannels() {
    const currentChannels = [];

    try {
      const res = await this._query.send("channellist");
      const channelSpacerRegex = new RegExp(".*spacer.*");
      for (let i = 0; i < res.channel_order.length; i++) {
        if (
          !this._config.allowChannelSpacers &&
          channelSpacerRegex.test(res.channel_name[i])
        ) {
          continue;
        }

        currentChannels.push(new TsChannel(res.cid[i], res.channel_name[i]));
      }
    } catch (err) {
      console.error("Could not get channellist:", err);
    }

    return currentChannels;
  }

  async _getCurrentOnlineClients() {
    const onlineClients = [];

    try {
      const res = await this._query.send("clientlist");
      for (let i = 0; i < res.clid.length; i++) {
        if (
          this._isIgnoredUser(
            this._config.ignoreUsersRegexList,
            res.client_nickname[i]
          )
        ) {
          continue;
        }
        onlineClients.push(
          new TsClient(res.clid[i], res.client_nickname[i], res.cid[i])
        );
      }
    } catch (err) {
      console.error("Could not get clientlist:", err);
    }

    return onlineClients;
  }
}

module.exports = TsViewer;
